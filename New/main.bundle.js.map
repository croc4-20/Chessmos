{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://chessmos/./classGame.js","webpack://chessmos/./classPiece.js","webpack://chessmos/./ex/classPiece.js","webpack://chessmos/./ex/classBoard.js","webpack://chessmos/./ex/classGame.js","webpack://chessmos/webpack/bootstrap","webpack://chessmos/webpack/runtime/define property getters","webpack://chessmos/webpack/runtime/hasOwnProperty shorthand","webpack://chessmos/webpack/runtime/make namespace object","webpack://chessmos/webpack/startup"],"sourcesContent":["import chessBoard from './ex/classBoard.js';\r\nimport chessPiece from './classPiece.js';\r\n\r\nclass chessGame\r\n{\r\n  constructor() \r\n  {\r\n    this.board = new Board();\r\n    this.whitePieces = [];\r\n    this.blackPieces = [];\r\n    this.currentTurn = 'white';\r\n    this.squares = document.querySelectorAll('.chess-square');  \r\n  }\r\n  startNewGame()\r\n\r\n  {\r\n    this.setupEventListeners();\r\n   // If the game is already over, display a message and return\r\n  if (this.checkGameOver()) \r\n  {\r\n    alert(\"The game is already over. Please start a new game.\");\r\n    return;\r\n\r\n  }\r\n\r\n  // Reset the board to the starting position\r\n  this.board.grid = [  \r\n    [{color: 'white', type: 'rook'}, {color: 'white', type: 'knight'}, {color: 'white', type: 'bishop'}, {color: 'white', type: 'queen'}, {color: 'white', type: 'king'}, {color: 'white', type: 'bishop'}, {color: 'white', type: 'knight'}, {color: 'white', type: 'rook'}],\r\n    [{color: 'white', type: 'pawn'}, {color: 'white', type: 'pawn'}, {color: 'white', type: 'pawn'}, {color: 'white', type: 'pawn'}, {color: 'white', type: 'pawn'}, {color: 'white', type: 'pawn'}, {color: 'white', type: 'pawn'}, {color: 'white', type: 'pawn'}],\r\n    [null, null, null, null, null, null, null, null],\r\n    [null, null, null, null, null, null, null, null],\r\n    [null, null, null, null, null, null, null, null],\r\n    [null, null, null, null, null, null, null, null],\r\n    [{color: 'black', type: 'pawn'}, {color: 'black', type: 'pawn'}, {color: 'black', type: 'pawn'}, {color: 'black', type: 'pawn'}, {color: 'black', type: 'pawn'}, {color: 'black', type: 'pawn'}, {color: 'black', type: 'pawn'}, {color: 'black', type: 'pawn'}],\r\n    [{color: 'black', type: 'rook'}, {color: 'black', type: 'knight'}, {color: 'black', type: 'bishop'}, {color: 'black', type: 'queen'}, {color: 'black', type: 'king'}, {color: 'black', type: 'bishop'}, {color: 'black', type: 'knight'}, {color: 'black', type: 'rook'}]\r\n    ];\r\n    this.whiteTurn = true;\r\n    this.selectedPiece = null;\r\n    this.checkGameOver = () => {}\r\n\r\n    squares.forEach(square => square.innerHTML = \"\");\r\n\r\n    this.board.placePieces();\r\n  }\r\nhandleMove(fromRow, fromCol, toRow, toCol) \r\n{\r\n    // check if the move is legal and update the board and pieces accordingly\r\n  }\r\n\r\n  isCheckmate(color) \r\n  {\r\n    // check if the player with the specified color is in checkmate\r\n  }\r\n  \r\n\r\n  setupEventListeners() \r\n  {\r\n  // Initialize the board array\r\n  const squares = document.querySelectorAll('.chess-square');\r\n  const pieces = document.querySelectorAll('.chess-piece');\r\n\r\n  // Add event listeners to each square and piece\r\n  squares.forEach(square => \r\n  {\r\n    square.addEventListener('click', event => \r\n    {\r\n      // Handle square click event\r\n      highlightSquare(event.target);\r\n    });\r\n  });\r\n  pieces.forEach(piece => \r\n  {\r\n    piece.addEventListener('click', event => \r\n    {\r\n      // Handle piece click event\r\n    });\r\n  });\r\n}\r\nhighlightSquare(squareElement) \r\n  {\r\n  // Check if the clicked square is occupied by a piece\r\n  if (squareElement.children.length > 0) \r\n    {\r\n    // Get the piece element\r\n    const pieceElement = squareElement.children[0];\r\n\r\n    // Check if the piece is the correct color (based on the current player turn)\r\n    if (this.isWhiteTurn && pieceElement.classList.contains('white') || !this.isWhiteTurn && pieceElement.classList.contains('black'))\r\n \r\n      {\r\n        // Deselect the previously selected piece (if there was one)\r\n        if (this.selectedPiece) \r\n        {\r\n          this.selectedPiece.classList.remove('highlight');\r\n        }\r\n\r\n        // Add the 'highlight' class to the square element\r\n        squareElement.classList.add('highlight');\r\n\r\n        // Update the selected piece\r\n        this.selectedPiece = squareElement;\r\nconsole.log(piece);\r\n      }\r\n    }\r\n  }\r\n}\r\nexport default chessGame;\r\n    ","import chessBoard from './ex/classBoard.js';\r\nimport chessGame from './classGame.js';\r\n\r\n\r\n// Create a new instance of the Board class\r\nconst board = new chessBoard();\r\n//const pieceElement = this.createElement();\r\n\r\nconst game = new chessGame();\r\n(function() {\r\nclass chessPiece\r\n{\r\n  constructor(type, color, row, col, imagePath, element) \r\n  {\r\n    this.type = type;\r\n    this.color = (type === type.toLowerCase()) ? 'black' : 'white';\r\n    this.row = row;\r\n    this.col = col;\r\n    this.element = this.createElement();\r\n    this.element.addEventListener('click',this.handleClick.bind(this));\r\n    squareElement.appendChild(this.element);\r\n    this.handleClick = this.handleClick.bind(this);\r\n    this.isWhiteTurn = true;\r\n    \r\n  }\r\n\r\n  \r\n\r\n  handleClick(pieceElement) \r\n  {\r\n    console.log('piece clicked')\r\n// Check if it is the current player's turn to move\r\nif (this.isWhiteTurn !== (this.color === 'white')) \r\n{\r\n// It is not the current player's turn, so do nothing\r\nreturn;\r\n}\r\npieceElement.classList.add('selected-piece');\r\n// It is the current player's turn, so select the piece\r\nthis.selectedPiece = pieceElement;\r\n}\r\n\r\ncreateElement() \r\n{\r\nconst pieceElement = document.createElement('div');\r\npieceElement.classList.add(`chess-piece-${this.color}-${this.type}`);\r\npieceElement.dataset.color = this.color;\r\npieceElement.addEventListener('click', this.handleClick.bind(this));\r\nreturn pieceElement;\r\n}\r\n\r\n\r\n  addPiece(type, color, row, col, element) \r\n{\r\n  const pieceElement = new chessPiece(type, color, row, col).element;\r\n  const squareElement = document.getElementById(`${row}-${col}`);\r\n  squareElement.appendChild(pieceElement);\r\n}\r\n  \r\n  handlePieceSelection(selectedPiece, currentSquareElement) \r\n  {\r\n  // Highlight the selected piece\r\n  selectedPiece.classList.add(\"selected\");\r\n\r\n  // Add event listeners to each square on the board\r\n  const chessSquares = document.querySelectorAll(\".chess-square\");\r\n  chessSquares.forEach(square => \r\n  {\r\n    square.addEventListener(\"click\", function() \r\n    {\r\n      // Check if the move to the new square is legal\r\n      if (board.isLegalMove(selectedPiece, this, currentSquareElement)) \r\n      {\r\n        // If the move is legal, move the piece to the new square\r\n        this.appendChild(selectedPiece);\r\n\r\n        // Deselect the piece\r\n        deselectPiece(selectedPiece);\r\n      } \r\n      else \r\n      {\r\n        // If the move is not legal, display an error message\r\n        console.log(\"Illegal move!\");\r\n      }\r\n    });\r\n  });\r\n}\r\n  createChessPieces() \r\n  {\r\n  // Create an array of all the chess piece types\r\n    const pieceTypes = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'];\r\n\r\n  // Create an array of all the chess piece colors\r\n    const pieceColors = ['white', 'black'];\r\n\r\n  // Create an empty array to store all the chess pieces\r\n    const chessPieces = [];\r\n\r\n  // Loop through the piece types and colors\r\n    for (let type of pieceTypes) \r\n    {\r\n      for (let color of pieceColors) \r\n      {\r\n      // Create a new chess piece and add it to the array\r\n        chessPieces.push(new Piece(type, color));\r\n      }\r\n    }\r\n\r\n  // Loop through the chess pieces array and add each piece to the board\r\n    for (let piece of chessPieces) \r\n    {\r\n      addPiece(piece.type, piece.color, piece.row, piece.col);\r\n    }\r\n    createChessPieces();\r\n  }\r\n\r\ncurrentlySelectedPiece = null;\r\n\r\nselectPiece(pieceElement) {\r\n  // Deselect any previously selected piece\r\n  deselectPiece(currentlySelectedPiece);\r\n\r\n  // Select the new piece\r\n  currentlySelectedPiece = pieceElement;\r\n\r\n  // Get the current square element\r\n  const currentSquareElement = currentlySelectedPiece.parentElement;\r\n\r\n  // Highlight the selected piece\r\n  currentlySelectedPiece.classList.add(\"selected\");\r\n\r\n  // remove highlighting on the previously selected piece's valid squares\r\n  if(previouslySelectedPiece) {\r\n    removeHighlighting(previouslySelectedPiece);\r\n  }\r\n\r\n  // add highlighting on the new piece's valid squares\r\n  highlightValidMoves(currentlySelectedPiece);\r\n\r\n  // Other statements go here...\r\n\r\n  // Step 1: Add event listeners to each piece on the board\r\n  const chessPieces = document.querySelectorAll(\".chess-piece\");\r\n  chessPieces.forEach(piece => \r\n  {\r\n    piece.addEventListener(\"click\", function() \r\n    {\r\n      selectPiece(element);\r\n    });\r\n  });\r\n}\r\n\r\ndeselectPiece(selectedPiece) \r\n{\r\n  // Deselect the piece\r\n  selectedPiece.classList.remove(\"selected\");\r\n  // Remove event listeners from each square on the board\r\n  const chessSquares = document.querySelectorAll(\".chess-square\");\r\n  chessSquares.forEach(square => \r\n  {\r\n    square.removeEventListener(\"click\", function() {});\r\n  });\r\n}\r\nhighlightValidMoves(piece) \r\n{\r\n    const validMoves = piece.getValidMoves();\r\n    validMoves.forEach(([row, col]) => \r\n    {\r\n        const square = this.squareElements[row][col];\r\n        square.classList.add('highlight');\r\n    });\r\n}\r\n\r\n  handleMove(event) \r\n{\r\nlet isWhiteTurn; // Declare the isWhiteTurn variable\r\nlet selectedPiece;\r\n\r\n  // Check if the clicked element is a chess square\r\n  if (event.target.classList.contains(\"chess-square\")) \r\n  {\r\n    const selectedPiece = document.querySelector('.selected');\r\n\r\n    // Get the current position of the selected piece\r\n    const currentRow = Number(selectedPiece.id.split(\"-\")[0]);\r\n    const currentCol = Number(selectedPiece.id.split(\"-\")[1]);\r\n\r\n    // Get the clicked square's position\r\n    const newRow = Number(event.target.id.split(\"-\")[0]);\r\n    const newCol = Number(event.target.id.split(\"-\")[1]);\r\n\r\n    // Check if the move is valid (add your own logic here)\r\n    if (board.isValidMove(currentRow, currentCol, newRow, newCol)) \r\n    {\r\n      // Update the board state\r\n      board[newRow][newCol] = board[currentRow][currentCol];\r\n      board[currentRow][currentCol] = null;\r\n\r\n      // Update the DOM to reflect the new board state\r\n      event.target.appendChild(selectedPiece);\r\n      document.getElementById(`square-${currentRow}-${currentCol}`).innerHTML = \"\";\r\n\r\n      // Increment the timer by 1 minute\r\n      timer += 60;\r\n\r\n      // Switch player turn\r\n      let isWhiteTurn = !isWhiteTurn;\r\n\r\n    }\r\n  }\r\n  selectedPiece.classList.remove(\"selected\");\r\n\r\n  // Remove event listeners from each square on the board\r\n  const chessSquares = document.querySelectorAll(\".chess-square\");\r\n  chessSquares.forEach(square => \r\n  {\r\n    square.removeEventListener(\"click\", function() {});\r\n  });\r\n}\r\n\r\n  canAttack(piece, row, col, color) \r\n  {\r\n  // get the piece's type, color, and current position.\r\n  let type = piece.type;\r\n  let pieceRow = piece.row;\r\n  let pieceCol = piece.col;\r\n\r\n  // check if the piece can attack the square based on its type and color\r\n  switch(type) \r\n  {\r\n    case 'pawn':\r\n      // pawns can attack diagonally, one square ahead and to the left or right.\r\n      if (color === 'white' && Math.abs(pieceRow - row) == 1 && Math.abs(pieceCol - col) == 1 && row < pieceRow) {\r\n        return true;\r\n      } else if (color === 'black' && Math.abs(pieceRow - row) == 1 && Math.abs(pieceCol - col) == 1 && row > pieceRow) {\r\n        return true;\r\n      }\r\n      break;\r\n    case 'rook':\r\n      // rooks can attack horizontally or vertically, as long as there are no pieces blocking their path\r\n      if (pieceRow == row || pieceCol == col) {\r\n        // check for pieces blocking the rook's path.\r\n        if (!isBlocked(piece, row, col)) {\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n    case 'knight':\r\n      // knights can attack squares that are two rows and one column, or two columns and one row away.\r\n      if ((Math.abs(pieceRow - row) == 2 && Math.abs(pieceCol - col) == 1) || (Math.abs(pieceRow - row) == 1 && Math.abs(pieceCol - col) == 2)) {\r\n        return true;\r\n      }\r\n      break;\r\n    case 'bishop':\r\n      // bishops can attack diagonally, as long as there are no pieces blocking their path.\r\n      if (Math.abs(pieceRow - row) == Math.abs(pieceCol - col)) {\r\n        // check for pieces blocking the bishop's path\r\n        if (!isBlocked(piece, row, col)) {\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n    case 'queen':\r\n      // queens can attack horizontally, vertically, or diagonally, as long as there are no pieces blocking their path\r\n      if (pieceRow == row || pieceCol == col || Math.abs(pieceRow - row) == Math.abs(pieceCol - col)) {\r\n        // check for pieces blocking the queen's path\r\n        if (!isBlocked(piece, row, col)) {\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n    case 'king':\r\n      // kings can attack squares that are one row and one column away\r\n      if (Math.abs(pieceRow - row) <= 1 && Math.abs(pieceCol - col) <= 1) {\r\n        return true;\r\n      }\r\n      break;\r\n  }\r\n\r\n  // if none of the above conditions are met, the piece cannot attack the square\r\n  return false;\r\n}\r\n\r\n  isValidMove(currentPiece, currentRow, currentCol, newRow, newCol) {\r\n  // get the type and color of the piece\r\n  let type = currentPiece.type;\r\n  let color = currentPiece.color;\r\n  const piece = new chessPiece(pieceElement);\r\n  // check if the piece can move to the new square based on its type and the rules of chess\r\n  switch(type) \r\n  {\r\n    case 'pawn':\r\n      // pawns can move forward one square, or forward two squares on their first move\r\n      if (color == 'white') \r\n      {\r\n        if (newRow == currentRow - 1 && newCol == currentCol && !board[newRow][newCol]) {\r\n          // move is valid\r\n          return true;\r\n        } else if (newRow == currentRow - 2 && newCol == currentCol && !board[newRow][newCol] && !board[currentRow - 1][currentCol] && currentRow == 6) {\r\n          // move is valid\r\n          return true;\r\n        }\r\n      } \r\n      else if (color == 'black') \r\n      {\r\n        if (newRow == currentRow + 1 && newCol == currentCol && !board[newRow][newCol]) {\r\n          // move is valid\r\n          return true;\r\n        } else if (newRow == currentRow + 2 && newCol == currentCol && !board[newRow][newCol] && !board[currentRow + 1][currentCol] && currentRow == 1) {\r\n          // move is valid\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n    case 'rook':\r\n      // rooks can move horizontally or vertically, as long as there are no pieces blocking their path\r\n      if (newRow == currentRow || newCol == currentCol) \r\n      {\r\n        // check for pieces blocking the rook's path\r\n        if (!isBlocked(piece, newRow, newCol)) \r\n        {\r\n          // move is valid\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n    case 'knight':\r\n      // knights can move to squares that are two rows and one column, or two columns and one row away\r\n      if ((Math.abs(newRow - currentRow) == 2 && Math.abs(newCol - currentCol) == 1) || (Math.abs(newRow - currentRow) == 1 && Math.abs(newCol - currentCol) == 2)) {\r\n        // move is valid\r\n        return true;\r\n      }\r\n      break;\r\n    case 'bishop':\r\n      // bishops can move diagonally, as long as there are no pieces blocking their path\r\n      if (Math.abs(newRow - currentRow) == Math.abs(newCol - currentCol)) {\r\n        // check for pieces blocking the bishop's path\r\n        if (!isBlocked(piece, newRow, newCol)) \r\n        {\r\n          // move is valid\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n      case 'queen':\r\n      // queens can move horizontally, vertically, or diagonally, as long as there are no pieces blocking their path\r\n        if (newRow == currentRow || newCol == currentCol || Math.abs(newRow - currentRow) == Math.abs(newCol - currentCol)) {\r\n        // check for pieces blocking the queen's path\r\n          if (!isBlocked(currentRow, currentCol, newRow, newCol)) \r\n          {\r\n            return true;\r\n          }\r\n        }\r\n        break;\r\n      case 'king':\r\n      // kings can move to any adjacent square (horizontally, vertically, or diagonally)\r\n        if (Math.abs(newRow - currentRow) <= 1 && Math.abs(newCol - currentCol) <= 1) \r\n        {\r\n          return true;\r\n        }\r\n        break;\r\n      default:\r\n      // if the piece is not recognized, return false\r\n        return false;\r\n      }\r\n       if (piece.isValidMove(currentRow, currentCol, newRow, newCol)) \r\n       {\r\n    return true;\r\n  } \r\n  else \r\n  {\r\n    return false;\r\n  }\r\n}\r\n  getType() \r\n  {\r\n  // returns the type of the piece (e.g. \"pawn\", \"rook\", etc.)\r\n    return this.type;\r\n  }\r\n\r\n  getColor() \r\n  {\r\n    // returns the color of the piece (e.g. \"white\", \"black\")\r\n    return this.color;\r\n  }\r\n  getKing(color) \r\n  {\r\n    // iterate over all of the squares on the board\r\n    for (let i = 0; i < 8; i++) \r\n    {\r\n      for (let j = 0; j < 8; j++) \r\n      {\r\n        // get the piece at the current square\r\n        let piece = board.getGrid()[i][j];\r\n\r\n        // if the piece is a king of the right color, return it\r\n        if (piece && piece.type == 'king' && piece.color == color) \r\n        {\r\n          return piece;\r\n        }\r\n      }\r\n    }\r\n  }\r\ngetPosition() \r\n{\r\n  // returns the current position of the piece on the board as an array [row, col]\r\n  return [this.row, this.col];\r\n}\r\n\r\nsetPosition(row, col) \r\n{\r\n  // sets the position of the piece on the board\r\n  this.row = row;\r\n  this.col = col;\r\n}\r\nplayMoveSound() \r\n  {\r\n    const audioElement = document.createElement('audio');\r\n    audioElement.src = '/sounds/move.mp3';\r\n    document.body.appendChild(audioElement);\r\n    audioElement.play();\r\n  }\r\n\r\n  playCaptureSound() \r\n  {\r\n    const audioElement = document.createElement('audio');\r\n    audioElement.src = '/sounds/capture.mp3';\r\n    document.body.appendChild(audioElement);\r\n    audioElement.play();\r\n  }\r\n\r\n  playWrongSound() \r\n  {\r\n    // create an audio element for the wrong sound\r\n    const audioElement = document.createElement('audio');\r\n    audioElement.src = '/sounds/wrong.mp3';\r\n    document.body.appendChild(audioElement);\r\n    // play the sound\r\n    audioElement.play();\r\n  }\r\n  checkGameOver() \r\n  {\r\n    // check if either player has no pieces left\r\n    if (getNumWhitePieces() == 0 || getNumBlackPieces() == 0) \r\n    {\r\n      return true;\r\n    }\r\n\r\n    // check if either player is in checkmate\r\n    if (isCheckmate('white') || isCheckmate('black')) \r\n    {\r\n      return true;\r\n    }\r\n\r\n    // check if the game is a draw (e.g., insufficient material to checkmate)\r\n    if (isDraw()) \r\n    {\r\n      return true;\r\n    }\r\n\r\n    // if none of the above conditions are met, the game is not over\r\n    return false;\r\n  }\r\n\r\n  checkGameStatus() \r\n  {\r\n    if (checkGameOver()) \r\n  {\r\n    // game is over\r\n    // do something here to end the game (e.g., display a message or redirect to a game over screen)\r\n  } \r\n  else \r\n  {\r\n    // game is not over\r\n    // continue playing the game as normal\r\n  }\r\n}\r\n\r\n  \r\n  isLegalMove(piece, newSquare, board, currentSquare) \r\n  {\r\n  // Get the piece's type (e.g. pawn, knight, etc.) and color\r\n  const pieceType = piece.type;\r\n  const pieceColor = piece.color;\r\n  // Get the current and new square coordinates\r\n  const currentSquareCoords = getSquareCoords(currentSquare);\r\n  const newSquareCoords = getSquareCoords(newSquare);\r\n\r\n  switch (pieceType) \r\n  {\r\n    case \"queen\":\r\n      // Queens can move diagonally, horizontally, or vertically any number of squares, as long as there are no other pieces blocking the way\r\n      // Check if the move is diagonal\r\n      if (Math.abs(newSquareCoords[0] - currentSquareCoords[0]) === Math.abs(newSquareCoords[1] - currentSquareCoords[1])) {\r\n        if (!isClearPath(board, currentSquareCoords[0], currentSquareCoords[1], newSquareCoords[0], newSquareCoords[1])) \r\n        {\r\n          return false;\r\n        }\r\n      }\r\n      // Check if the move is horizontal or vertical\r\n      if (newSquareCoords[0] === currentSquareCoords[0] || newSquareCoords[1] === currentSquareCoords[1]) \r\n      {\r\n        if (!isClearPath(board, currentSquareCoords[0], currentSquareCoords[1], newSquareCoords[0], newSquareCoords[1])) \r\n        {\r\n          return false;\r\n        }\r\n      }\r\n        return true;\r\n    case \"rook\":\r\n      // Rooks can move horizontally or vertically any number of squares, as long as there are no other pieces blocking the way\r\n      // Check if the move is horizontal or vertical\r\n      if (newSquareCoords[0] === currentSquareCoords[0] || newSquareCoords[1] === currentSquareCoords[1]) \r\n      {\r\n        if (!isClearPath(board, currentSquareCoords[0], currentSquareCoords[1], newSquareCoords[0], newSquareCoords[1])) \r\n        {\r\n          return false;\r\n        }\r\n      }\r\n      break;\r\n    case \"bishop\":\r\n      // Check if the move is diagonal\r\nif (Math.abs(newSquareCoords[0] - currentSquareCoords[0]) === Math.abs(newSquareCoords[1] - currentSquareCoords[1])) \r\n{\r\n  // Check if there are no pieces blocking the way\r\n  if (isClearPath(board, currentSquareCoords[0], currentSquareCoords[1], newSquareCoords[0], newSquareCoords[1])) \r\n  {\r\n    // The move is legal\r\n    return true;\r\n  }\r\n}\r\n\r\n// The move is not legal\r\nreturn false;\r\n\r\n  case \"knight\":\r\n    // Knights can move in an L-shaped pattern (two squares in one direction, and one square in the other)\r\n    return ((\r\n      Math.abs(newSquareCoords[0] - currentSquareCoords[0]) === 2 &&\r\n      Math.abs(newSquareCoords[1] - currentSquareCoords[1]) === 1\r\n       ) ||\r\n     (Math.abs(newSquareCoords[0] - currentSquareCoords[0]) === 1 &&\r\n      Math.abs(newSquareCoords[1] - currentSquareCoords[1]) === 2)\r\n     );\r\n  case \"pawn\":\r\n    // Pawns can only move forward one square, unless it is their first move and they are allowed to move two squares\r\n    // They can also capture pieces diagonally\r\n    if (pieceColor === \"white\")\r\n    {\r\n      // White pawns can only move forward\r\n      if (newSquareCoords[0] === currentSquareCoords[0] - 1) \r\n      {\r\n        // Check if the pawn is moving straight ahead\r\n        if (newSquareCoords[1] === currentSquareCoords[1]) \r\n        {\r\n          // Check if the square is unoccupied\r\n          if (!getPieceOnSquare(newSquare)) \r\n          {\r\n            return true;\r\n          }\r\n        }\r\n        // Check if the pawn is capturing a piece\r\n        if (Math.abs(newSquareCoords[1] - currentSquareCoords[1]) === 1) \r\n        {\r\n          // Check if the square is occupied by an enemy piece\r\n          const enemyPiece = getPieceOnSquare(newSquare);\r\n          if (enemyPiece && enemyPiece.classList[1] !== pieceColor) \r\n          {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      // Check if the pawn is making a double move (on their first move only)\r\n        // Black pawns can only move backwards\r\n  if (newSquareCoords[0] === currentSquareCoords[0] + 1) \r\n  {\r\n    // Check if the pawn is moving straight ahead\r\n    if (newSquareCoords[1] === currentSquareCoords[1]) \r\n    {\r\n      // Check if the square is unoccupied\r\n      if (!getPieceOnSquare(newSquare)) \r\n      {\r\n        return true;\r\n      }\r\n    }\r\n    // Check if the pawn is capturing a piece\r\n    if (Math.abs(newSquareCoords[1] - currentSquareCoords[1]) === 1) \r\n    {\r\n      // Check if the square is occupied by an enemy piece\r\n      const enemyPiece = getPieceOnSquare(newSquare);\r\n      if (enemyPiece && enemyPiece.classList[1] !== pieceColor) \r\n      {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  // Check if the pawn is making a double move (on their first move only)\r\n  if (\r\n    (newSquareCoords[0] === currentSquareCoords[0] + 2 &&\r\n    newSquareCoords[1] === currentSquareCoords[1] &&\r\n    !piece.hasMoved)\r\n    )\r\n  {\r\n    // Check that there are no pieces blocking the move\r\n    const squareInBetween = document.getElementById(\r\n      `square-${currentSquareCoords[0] + 1}-${currentSquareCoords[1]}`\r\n    );\r\n    if (!getPieceOnSquare(squareInBetween)) \r\n    {\r\n      return true;\r\n    }\r\n   \r\n  }\r\n  break;\r\n}\r\ndefault:\r\n case \"king\":\r\n      // Kings can move one square in any direction\r\n      if (\r\n        Math.abs(newSquareCoords[0] - currentSquareCoords[0]) <= 1 &&\r\n        Math.abs(newSquareCoords[1] - currentSquareCoords[1]) <= 1\r\n      ) \r\n      {\r\n        return true;\r\n      }\r\n      // Kings can also castle (move two squares towards the rook) if certain conditions are met\r\n      if (\r\n        newSquareCoords[1] === currentSquareCoords[1] + 2 &&\r\n        !piece.hasMoved\r\n      ) \r\n      {\r\n        // Check that there are no pieces between the king and the rook\r\n        const rightSquare = document.getElementById(\r\n          `square-${currentSquareCoords[0]}-${currentSquareCoords[1] + 1}`\r\n        );\r\n        const rookSquare = document.getElementById(\r\n          `square-${currentSquareCoords[0]}-${currentSquareCoords[1] + 3}`\r\n        );\r\n        if (getPieceOnSquare(rightSquare) || getPieceOnSquare(rookSquare)) \r\n        {\r\n          return false;\r\n        }\r\n        // Check that the rook has not moved\r\n        const rook = getPieceOnSquare(rookSquare);\r\n        if (rook && rook.hasMoved) \r\n        {\r\n          return false;\r\n        }\r\n        // Check that the king is not in check\r\n        if (isSquareInCheck(board, currentSquare)) \r\n        {\r\n          return false;\r\n        }\r\n        // Check that the king does not move through a square that is in check\r\n        if (\r\n          isSquareInCheck(board, rightSquare) ||\r\n          isSquareInCheck(board, newSquare)\r\n        ) \r\n        {\r\n          return false;\r\n        }\r\n        return true;\r\n      }\r\n      if (\r\n        newSquareCoords[1] === currentSquareCoords[1] - 2 &&\r\n        !piece.hasMoved\r\n      ) \r\n      {\r\n        // Check that there are no pieces between the king and the rook\r\n        const leftSquare = document.getElementById(\r\n          `square-${currentSquareCoords[0]}-${currentSquareCoords[1] - 1}`\r\n        );\r\n        const rookSquare = document.getElementById(\r\n          `square-${currentSquareCoords[0]}-${currentSquareCoords[1] - 4}`\r\n        );\r\n        if (getPieceOnSquare(leftSquare) || getPieceOnSquare(rookSquare)) \r\n        {\r\n          return false;\r\n        }\r\n        // Check that the rook has not moved\r\n        const rook = getPieceOnSquare(rookSquare);\r\n        if (rook && rook.hasMoved) \r\n        {\r\n          return false;\r\n        }\r\n        // Check that the king is not in check\r\n        if (isSquareInCheck(board, currentSquare)) \r\n        {\r\n          return false;\r\n        }\r\n        // Check that the king does not move through a square that is in check\r\n        if (\r\n          isSquareInCheck(board, leftSquare) ||\r\n          isSquareInCheck(board, newSquare)\r\n        ) \r\n        {\r\n          return false;\r\n        }\r\n        return true;\r\n      }\r\n      //break;\r\n    }\r\n    }\r\n    isClearPath(board, currentRow, currentCol, newRow, newCol) \r\n    {\r\n    // Check if the move is horizontal or vertical\r\n      if (currentRow === newRow || currentCol === newCol) \r\n      {\r\n      // Check if the path is clear along the row or column\r\n        const start = Math.min(currentRow, newRow);\r\n        const end = Math.max(currentRow, newRow);\r\n        for (let i = start + 1; i < end; i++) \r\n        {\r\n          if (board[i][currentCol]) \r\n          {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n      // The move is diagonal\r\n      // Check if the path is clear along the diagona\r\n        const rowDiff = Math.abs(newRow - currentRow);\r\n        const colDiff = Math.abs(newCol - currentCol);\r\n        if (rowDiff !== colDiff) \r\n        {\r\n      // The move is not diagonal\r\n          return false;\r\n        }\r\n        const rowStep = (newRow - currentRow) / rowDiff;\r\n        const colStep = (newCol - currentCol) / colDiff;\r\n        let row = currentRow + rowStep;\r\n        let col = currentCol + colStep;\r\n        while (row !== newRow && col !== newCol) \r\n        {\r\n          if (board[row][col]) \r\n          {\r\n            return false;\r\n          }\r\n          row += rowStep;\r\n          col += colStep;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n\r\n\r\n  }\r\n  })();\r\n  \r\n  export default chessPiece;","import chessBoard from './classBoard.js';\nimport chessGame from './classGame.js';\n\n// Create a new instance of the Board class\nconst board = new chessBoard();\n//const pieceElement = this.createElement();\n\nconst game = new chessGame();\n(function () {\n  class chessPiece {\n    constructor(type, color, row, col, imagePath, element) {\n      this.type = type;\n      this.color = type === type.toLowerCase() ? 'black' : 'white';\n      this.row = row;\n      this.col = col;\n      this.element = this.createElement();\n      this.element.addEventListener('click', this.handleClick.bind(this));\n      squareElement.appendChild(this.element);\n      this.handleClick = this.handleClick.bind(this);\n      this.isWhiteTurn = true;\n    }\n\n    handleClick(pieceElement) {\n      console.log('piece clicked');\n      // Check if it is the current player's turn to move\n      if (this.isWhiteTurn !== (this.color === 'white')) {\n        // It is not the current player's turn, so do nothing\n        return;\n      }\n      pieceElement.classList.add('selected-piece');\n      // It is the current player's turn, so select the piece\n      this.selectedPiece = pieceElement;\n    }\n\n    createElement() {\n      const pieceElement = document.createElement('div');\n      pieceElement.classList.add(`chess-piece-${this.color}-${this.type}`);\n      pieceElement.dataset.color = this.color;\n      pieceElement.addEventListener('click', this.handleClick.bind(this));\n      return pieceElement;\n    }\n\n    addPiece(type, color, row, col, element) {\n      const pieceElement = new chessPiece(type, color, row, col).element;\n      const squareElement = document.getElementById(`${row}-${col}`);\n      squareElement.appendChild(pieceElement);\n    }\n\n    handlePieceSelection(selectedPiece, currentSquareElement) {\n      // Highlight the selected piece\n      selectedPiece.classList.add(\"selected\");\n\n      // Add event listeners to each square on the board\n      const chessSquares = document.querySelectorAll(\".chess-square\");\n      chessSquares.forEach(square => {\n        square.addEventListener(\"click\", function () {\n          // Check if the move to the new square is legal\n          if (board.isLegalMove(selectedPiece, this, currentSquareElement)) {\n            // If the move is legal, move the piece to the new square\n            this.appendChild(selectedPiece);\n\n            // Deselect the piece\n            deselectPiece(selectedPiece);\n          } else {\n            // If the move is not legal, display an error message\n            console.log(\"Illegal move!\");\n          }\n        });\n      });\n    }\n    createChessPieces() {\n      // Create an array of all the chess piece types\n      const pieceTypes = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'];\n\n      // Create an array of all the chess piece colors\n      const pieceColors = ['white', 'black'];\n\n      // Create an empty array to store all the chess pieces\n      const chessPieces = [];\n\n      // Loop through the piece types and colors\n      for (let type of pieceTypes) {\n        for (let color of pieceColors) {\n          // Create a new chess piece and add it to the array\n          chessPieces.push(new Piece(type, color));\n        }\n      }\n\n      // Loop through the chess pieces array and add each piece to the board\n      for (let piece of chessPieces) {\n        addPiece(piece.type, piece.color, piece.row, piece.col);\n      }\n      createChessPieces();\n    }\n\n    //currentlySelectedPiece = null;\n\n    selectPiece(pieceElement) {\n      // Deselect any previously selected piece\n      deselectPiece(currentlySelectedPiece);\n\n      // Select the new piece\n      currentlySelectedPiece = pieceElement;\n\n      // Get the current square element\n      const currentSquareElement = currentlySelectedPiece.parentElement;\n\n      // Highlight the selected piece\n      currentlySelectedPiece.classList.add(\"selected\");\n\n      // remove highlighting on the previously selected piece's valid squares\n      if (previouslySelectedPiece) {\n        removeHighlighting(previouslySelectedPiece);\n      }\n\n      // add highlighting on the new piece's valid squares\n      highlightValidMoves(currentlySelectedPiece);\n\n      // Other statements go here...\n\n      // Step 1: Add event listeners to each piece on the board\n      const chessPieces = document.querySelectorAll(\".chess-piece\");\n      chessPieces.forEach(piece => {\n        piece.addEventListener(\"click\", function () {\n          selectPiece(element);\n        });\n      });\n    }\n\n    deselectPiece(selectedPiece) {\n      // Deselect the piece\n      selectedPiece.classList.remove(\"selected\");\n      // Remove event listeners from each square on the board\n      const chessSquares = document.querySelectorAll(\".chess-square\");\n      chessSquares.forEach(square => {\n        square.removeEventListener(\"click\", function () {});\n      });\n    }\n    highlightValidMoves(piece) {\n      const validMoves = piece.getValidMoves();\n      validMoves.forEach(([row, col]) => {\n        const square = this.squareElements[row][col];\n        square.classList.add('highlight');\n      });\n    }\n\n    handleMove(event) {\n      let isWhiteTurn; // Declare the isWhiteTurn variable\n      let selectedPiece;\n\n      // Check if the clicked element is a chess square\n      if (event.target.classList.contains(\"chess-square\")) {\n        const selectedPiece = document.querySelector('.selected');\n\n        // Get the current position of the selected piece\n        const currentRow = Number(selectedPiece.id.split(\"-\")[0]);\n        const currentCol = Number(selectedPiece.id.split(\"-\")[1]);\n\n        // Get the clicked square's position\n        const newRow = Number(event.target.id.split(\"-\")[0]);\n        const newCol = Number(event.target.id.split(\"-\")[1]);\n\n        // Check if the move is valid (add your own logic here)\n        if (board.isValidMove(currentRow, currentCol, newRow, newCol)) {\n          // Update the board state\n          board[newRow][newCol] = board[currentRow][currentCol];\n          board[currentRow][currentCol] = null;\n\n          // Update the DOM to reflect the new board state\n          event.target.appendChild(selectedPiece);\n          document.getElementById(`square-${currentRow}-${currentCol}`).innerHTML = \"\";\n\n          // Increment the timer by 1 minute\n          timer += 60;\n\n          // Switch player turn\n          let isWhiteTurn = !isWhiteTurn;\n        }\n      }\n      selectedPiece.classList.remove(\"selected\");\n\n      // Remove event listeners from each square on the board\n      const chessSquares = document.querySelectorAll(\".chess-square\");\n      chessSquares.forEach(square => {\n        square.removeEventListener(\"click\", function () {});\n      });\n    }\n\n    canAttack(piece, row, col, color) {\n      // get the piece's type, color, and current position.\n      let type = piece.type;\n      let pieceRow = piece.row;\n      let pieceCol = piece.col;\n\n      // check if the piece can attack the square based on its type and color\n      switch (type) {\n        case 'pawn':\n          // pawns can attack diagonally, one square ahead and to the left or right.\n          if (color === 'white' && Math.abs(pieceRow - row) == 1 && Math.abs(pieceCol - col) == 1 && row < pieceRow) {\n            return true;\n          } else if (color === 'black' && Math.abs(pieceRow - row) == 1 && Math.abs(pieceCol - col) == 1 && row > pieceRow) {\n            return true;\n          }\n          break;\n        case 'rook':\n          // rooks can attack horizontally or vertically, as long as there are no pieces blocking their path\n          if (pieceRow == row || pieceCol == col) {\n            // check for pieces blocking the rook's path.\n            if (!isBlocked(piece, row, col)) {\n              return true;\n            }\n          }\n          break;\n        case 'knight':\n          // knights can attack squares that are two rows and one column, or two columns and one row away.\n          if (Math.abs(pieceRow - row) == 2 && Math.abs(pieceCol - col) == 1 || Math.abs(pieceRow - row) == 1 && Math.abs(pieceCol - col) == 2) {\n            return true;\n          }\n          break;\n        case 'bishop':\n          // bishops can attack diagonally, as long as there are no pieces blocking their path.\n          if (Math.abs(pieceRow - row) == Math.abs(pieceCol - col)) {\n            // check for pieces blocking the bishop's path\n            if (!isBlocked(piece, row, col)) {\n              return true;\n            }\n          }\n          break;\n        case 'queen':\n          // queens can attack horizontally, vertically, or diagonally, as long as there are no pieces blocking their path\n          if (pieceRow == row || pieceCol == col || Math.abs(pieceRow - row) == Math.abs(pieceCol - col)) {\n            // check for pieces blocking the queen's path\n            if (!isBlocked(piece, row, col)) {\n              return true;\n            }\n          }\n          break;\n        case 'king':\n          // kings can attack squares that are one row and one column away\n          if (Math.abs(pieceRow - row) <= 1 && Math.abs(pieceCol - col) <= 1) {\n            return true;\n          }\n          break;\n      }\n\n      // if none of the above conditions are met, the piece cannot attack the square\n      return false;\n    }\n\n    isValidMove(currentPiece, currentRow, currentCol, newRow, newCol) {\n      // get the type and color of the piece\n      let type = currentPiece.type;\n      let color = currentPiece.color;\n      const piece = new chessPiece(pieceElement);\n      // check if the piece can move to the new square based on its type and the rules of chess\n      switch (type) {\n        case 'pawn':\n          // pawns can move forward one square, or forward two squares on their first move\n          if (color == 'white') {\n            if (newRow == currentRow - 1 && newCol == currentCol && !board[newRow][newCol]) {\n              // move is valid\n              return true;\n            } else if (newRow == currentRow - 2 && newCol == currentCol && !board[newRow][newCol] && !board[currentRow - 1][currentCol] && currentRow == 6) {\n              // move is valid\n              return true;\n            }\n          } else if (color == 'black') {\n            if (newRow == currentRow + 1 && newCol == currentCol && !board[newRow][newCol]) {\n              // move is valid\n              return true;\n            } else if (newRow == currentRow + 2 && newCol == currentCol && !board[newRow][newCol] && !board[currentRow + 1][currentCol] && currentRow == 1) {\n              // move is valid\n              return true;\n            }\n          }\n          break;\n        case 'rook':\n          // rooks can move horizontally or vertically, as long as there are no pieces blocking their path\n          if (newRow == currentRow || newCol == currentCol) {\n            // check for pieces blocking the rook's path\n            if (!isBlocked(piece, newRow, newCol)) {\n              // move is valid\n              return true;\n            }\n          }\n          break;\n        case 'knight':\n          // knights can move to squares that are two rows and one column, or two columns and one row away\n          if (Math.abs(newRow - currentRow) == 2 && Math.abs(newCol - currentCol) == 1 || Math.abs(newRow - currentRow) == 1 && Math.abs(newCol - currentCol) == 2) {\n            // move is valid\n            return true;\n          }\n          break;\n        case 'bishop':\n          // bishops can move diagonally, as long as there are no pieces blocking their path\n          if (Math.abs(newRow - currentRow) == Math.abs(newCol - currentCol)) {\n            // check for pieces blocking the bishop's path\n            if (!isBlocked(piece, newRow, newCol)) {\n              // move is valid\n              return true;\n            }\n          }\n          break;\n        case 'queen':\n          // queens can move horizontally, vertically, or diagonally, as long as there are no pieces blocking their path\n          if (newRow == currentRow || newCol == currentCol || Math.abs(newRow - currentRow) == Math.abs(newCol - currentCol)) {\n            // check for pieces blocking the queen's path\n            if (!isBlocked(currentRow, currentCol, newRow, newCol)) {\n              return true;\n            }\n          }\n          break;\n        case 'king':\n          // kings can move to any adjacent square (horizontally, vertically, or diagonally)\n          if (Math.abs(newRow - currentRow) <= 1 && Math.abs(newCol - currentCol) <= 1) {\n            return true;\n          }\n          break;\n        default:\n          // if the piece is not recognized, return false\n          return false;\n      }\n      if (piece.isValidMove(currentRow, currentCol, newRow, newCol)) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    getType() {\n      // returns the type of the piece (e.g. \"pawn\", \"rook\", etc.)\n      return this.type;\n    }\n\n    getColor() {\n      // returns the color of the piece (e.g. \"white\", \"black\")\n      return this.color;\n    }\n    getKing(color) {\n      // iterate over all of the squares on the board\n      for (let i = 0; i < 8; i++) {\n        for (let j = 0; j < 8; j++) {\n          // get the piece at the current square\n          let piece = board.getGrid()[i][j];\n\n          // if the piece is a king of the right color, return it\n          if (piece && piece.type == 'king' && piece.color == color) {\n            return piece;\n          }\n        }\n      }\n    }\n    getPosition() {\n      // returns the current position of the piece on the board as an array [row, col]\n      return [this.row, this.col];\n    }\n\n    setPosition(row, col) {\n      // sets the position of the piece on the board\n      this.row = row;\n      this.col = col;\n    }\n    playMoveSound() {\n      const audioElement = document.createElement('audio');\n      audioElement.src = '/sounds/move.mp3';\n      document.body.appendChild(audioElement);\n      audioElement.play();\n    }\n\n    playCaptureSound() {\n      const audioElement = document.createElement('audio');\n      audioElement.src = '/sounds/capture.mp3';\n      document.body.appendChild(audioElement);\n      audioElement.play();\n    }\n\n    playWrongSound() {\n      // create an audio element for the wrong sound\n      const audioElement = document.createElement('audio');\n      audioElement.src = '/sounds/wrong.mp3';\n      document.body.appendChild(audioElement);\n      // play the sound\n      audioElement.play();\n    }\n    checkGameOver() {\n      // check if either player has no pieces left\n      if (getNumWhitePieces() == 0 || getNumBlackPieces() == 0) {\n        return true;\n      }\n\n      // check if either player is in checkmate\n      if (isCheckmate('white') || isCheckmate('black')) {\n        return true;\n      }\n\n      // check if the game is a draw (e.g., insufficient material to checkmate)\n      if (isDraw()) {\n        return true;\n      }\n\n      // if none of the above conditions are met, the game is not over\n      return false;\n    }\n\n    checkGameStatus() {\n      if (checkGameOver()) {\n        // game is over\n        // do something here to end the game (e.g., display a message or redirect to a game over screen)\n      } else {\n          // game is not over\n          // continue playing the game as normal\n        }\n    }\n\n    isLegalMove(piece, newSquare, board, currentSquare) {\n      // Get the piece's type (e.g. pawn, knight, etc.) and color\n      const pieceType = piece.type;\n      const pieceColor = piece.color;\n      // Get the current and new square coordinates\n      const currentSquareCoords = getSquareCoords(currentSquare);\n      const newSquareCoords = getSquareCoords(newSquare);\n\n      switch (pieceType) {\n        case \"queen\":\n          // Queens can move diagonally, horizontally, or vertically any number of squares, as long as there are no other pieces blocking the way\n          // Check if the move is diagonal\n          if (Math.abs(newSquareCoords[0] - currentSquareCoords[0]) === Math.abs(newSquareCoords[1] - currentSquareCoords[1])) {\n            if (!isClearPath(board, currentSquareCoords[0], currentSquareCoords[1], newSquareCoords[0], newSquareCoords[1])) {\n              return false;\n            }\n          }\n          // Check if the move is horizontal or vertical\n          if (newSquareCoords[0] === currentSquareCoords[0] || newSquareCoords[1] === currentSquareCoords[1]) {\n            if (!isClearPath(board, currentSquareCoords[0], currentSquareCoords[1], newSquareCoords[0], newSquareCoords[1])) {\n              return false;\n            }\n          }\n          return true;\n        case \"rook\":\n          // Rooks can move horizontally or vertically any number of squares, as long as there are no other pieces blocking the way\n          // Check if the move is horizontal or vertical\n          if (newSquareCoords[0] === currentSquareCoords[0] || newSquareCoords[1] === currentSquareCoords[1]) {\n            if (!isClearPath(board, currentSquareCoords[0], currentSquareCoords[1], newSquareCoords[0], newSquareCoords[1])) {\n              return false;\n            }\n          }\n          break;\n        case \"bishop\":\n          // Check if the move is diagonal\n          if (Math.abs(newSquareCoords[0] - currentSquareCoords[0]) === Math.abs(newSquareCoords[1] - currentSquareCoords[1])) {\n            // Check if there are no pieces blocking the way\n            if (isClearPath(board, currentSquareCoords[0], currentSquareCoords[1], newSquareCoords[0], newSquareCoords[1])) {\n              // The move is legal\n              return true;\n            }\n          }\n\n          // The move is not legal\n          return false;\n\n        case \"knight\":\n          // Knights can move in an L-shaped pattern (two squares in one direction, and one square in the other)\n          return Math.abs(newSquareCoords[0] - currentSquareCoords[0]) === 2 && Math.abs(newSquareCoords[1] - currentSquareCoords[1]) === 1 || Math.abs(newSquareCoords[0] - currentSquareCoords[0]) === 1 && Math.abs(newSquareCoords[1] - currentSquareCoords[1]) === 2;\n        case \"pawn\":\n          // Pawns can only move forward one square, unless it is their first move and they are allowed to move two squares\n          // They can also capture pieces diagonally\n          if (pieceColor === \"white\") {\n            // White pawns can only move forward\n            if (newSquareCoords[0] === currentSquareCoords[0] - 1) {\n              // Check if the pawn is moving straight ahead\n              if (newSquareCoords[1] === currentSquareCoords[1]) {\n                // Check if the square is unoccupied\n                if (!getPieceOnSquare(newSquare)) {\n                  return true;\n                }\n              }\n              // Check if the pawn is capturing a piece\n              if (Math.abs(newSquareCoords[1] - currentSquareCoords[1]) === 1) {\n                // Check if the square is occupied by an enemy piece\n                const enemyPiece = getPieceOnSquare(newSquare);\n                if (enemyPiece && enemyPiece.classList[1] !== pieceColor) {\n                  return true;\n                }\n              }\n            }\n            // Check if the pawn is making a double move (on their first move only)\n            // Black pawns can only move backwards\n            if (newSquareCoords[0] === currentSquareCoords[0] + 1) {\n              // Check if the pawn is moving straight ahead\n              if (newSquareCoords[1] === currentSquareCoords[1]) {\n                // Check if the square is unoccupied\n                if (!getPieceOnSquare(newSquare)) {\n                  return true;\n                }\n              }\n              // Check if the pawn is capturing a piece\n              if (Math.abs(newSquareCoords[1] - currentSquareCoords[1]) === 1) {\n                // Check if the square is occupied by an enemy piece\n                const enemyPiece = getPieceOnSquare(newSquare);\n                if (enemyPiece && enemyPiece.classList[1] !== pieceColor) {\n                  return true;\n                }\n              }\n            }\n            // Check if the pawn is making a double move (on their first move only)\n            if (newSquareCoords[0] === currentSquareCoords[0] + 2 && newSquareCoords[1] === currentSquareCoords[1] && !piece.hasMoved) {\n              // Check that there are no pieces blocking the move\n              const squareInBetween = document.getElementById(`square-${currentSquareCoords[0] + 1}-${currentSquareCoords[1]}`);\n              if (!getPieceOnSquare(squareInBetween)) {\n                return true;\n              }\n            }\n            break;\n          }\n        default:\n        case \"king\":\n          // Kings can move one square in any direction\n          if (Math.abs(newSquareCoords[0] - currentSquareCoords[0]) <= 1 && Math.abs(newSquareCoords[1] - currentSquareCoords[1]) <= 1) {\n            return true;\n          }\n          // Kings can also castle (move two squares towards the rook) if certain conditions are met\n          if (newSquareCoords[1] === currentSquareCoords[1] + 2 && !piece.hasMoved) {\n            // Check that there are no pieces between the king and the rook\n            const rightSquare = document.getElementById(`square-${currentSquareCoords[0]}-${currentSquareCoords[1] + 1}`);\n            const rookSquare = document.getElementById(`square-${currentSquareCoords[0]}-${currentSquareCoords[1] + 3}`);\n            if (getPieceOnSquare(rightSquare) || getPieceOnSquare(rookSquare)) {\n              return false;\n            }\n            // Check that the rook has not moved\n            const rook = getPieceOnSquare(rookSquare);\n            if (rook && rook.hasMoved) {\n              return false;\n            }\n            // Check that the king is not in check\n            if (isSquareInCheck(board, currentSquare)) {\n              return false;\n            }\n            // Check that the king does not move through a square that is in check\n            if (isSquareInCheck(board, rightSquare) || isSquareInCheck(board, newSquare)) {\n              return false;\n            }\n            return true;\n          }\n          if (newSquareCoords[1] === currentSquareCoords[1] - 2 && !piece.hasMoved) {\n            // Check that there are no pieces between the king and the rook\n            const leftSquare = document.getElementById(`square-${currentSquareCoords[0]}-${currentSquareCoords[1] - 1}`);\n            const rookSquare = document.getElementById(`square-${currentSquareCoords[0]}-${currentSquareCoords[1] - 4}`);\n            if (getPieceOnSquare(leftSquare) || getPieceOnSquare(rookSquare)) {\n              return false;\n            }\n            // Check that the rook has not moved\n            const rook = getPieceOnSquare(rookSquare);\n            if (rook && rook.hasMoved) {\n              return false;\n            }\n            // Check that the king is not in check\n            if (isSquareInCheck(board, currentSquare)) {\n              return false;\n            }\n            // Check that the king does not move through a square that is in check\n            if (isSquareInCheck(board, leftSquare) || isSquareInCheck(board, newSquare)) {\n              return false;\n            }\n            return true;\n          }\n        //break;\n      }\n    }\n    isClearPath(board, currentRow, currentCol, newRow, newCol) {\n      // Check if the move is horizontal or vertical\n      if (currentRow === newRow || currentCol === newCol) {\n        // Check if the path is clear along the row or column\n        const start = Math.min(currentRow, newRow);\n        const end = Math.max(currentRow, newRow);\n        for (let i = start + 1; i < end; i++) {\n          if (board[i][currentCol]) {\n            return false;\n          }\n        }\n      } else {\n        // The move is diagonal\n        // Check if the path is clear along the diagona\n        const rowDiff = Math.abs(newRow - currentRow);\n        const colDiff = Math.abs(newCol - currentCol);\n        if (rowDiff !== colDiff) {\n          // The move is not diagonal\n          return false;\n        }\n        const rowStep = (newRow - currentRow) / rowDiff;\n        const colStep = (newCol - currentCol) / colDiff;\n        let row = currentRow + rowStep;\n        let col = currentCol + colStep;\n        while (row !== newRow && col !== newCol) {\n          if (board[row][col]) {\n            return false;\n          }\n          row += rowStep;\n          col += colStep;\n        }\n      }\n      return true;\n    }\n\n  }\n})();\nexport default chessPiece;","import chessPiece from './classPiece.js';\nimport chessGame from './classGame.js';\nimport { createElements } from './classPiece.js';\nclass chessBoard {\n  constructor() {\n    this.squareElements = new Array(8).fill().map(() => new Array(8).fill(null));\n    this.grid = [['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'], ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']];\n\n    for (let i = 0; i < 8; i++) {\n      for (let j = 0; j < 8; j++) {\n        if (document.getElementById(`square-${i}-${j}`)) {\n          squareElements[i][j] = document.getElementById(`square-${i}-${j}`);\n        }\n      }\n    }\n    document.addEventListener(\"DOMContentLoaded\", function (event) {\n      // Create the elements\n      createElements();\n\n      // Create an instance of the chessBoard class\n      const board = new chessBoard();\n    });\n    console.log(squareElements);\n    this.chessPieces = [];\n\n    this.placePieces();\n    this.createBoard();\n    this.displayBoard();\n    this.updateGameState();\n    for (let i = 0; i < 8; i++) {\n      for (let j = 0; j < 8; j++) {\n        const square = this.grid[i][j];\n        if (square !== ' ') {\n          const color = square === square.toLowerCase() ? 'black' : 'white';\n          const type = square.toLowerCase();\n          const imagePath = `images/${color}${type.charAt(0).toUpperCase()}${type.slice(1)}.png`;\n          const element = squareElements[i][j];\n          //this.pieces.push(new Piece(type, color, i, j, imagePath, element));\n        }\n      }\n    }\n    this.addEventListeners();\n    this.handleClick = this.handleClick.bind(this);\n    //const chessPiece();\n  }\n  handleClick(event) {\n    // Do something with the event object\n    console.log(event);\n  }\n  handleSquareClick(squareElement) {\n    // Check if a piece is selected\n    if (!currentlySelectedPiece) {\n      // No piece is selected, so do nothing\n      return;\n    }\n    const toRow = parseInt(event.target.dataset.row);\n    const toCol = parseInt(event.target.dataset.col);\n\n    // Get the row and column of the selected piece\n    const fromRow = parseInt(currentlySelectedPiece.parentElement.dataset.row);\n    const fromCol = parseInt(currentlySelectedPiece.parentElement.dataset.col);\n\n    // Attempt to move the piece to the clicked square\n    if (board.movePiece(fromRow, fromCol, toRow, toCol)) {\n      // The move was successful, so update the current turn\n      this.isWhiteTurn = !this.isWhiteTurn;\n    }\n\n    // Deselect the piece\n    currentlySelectedPiece = null;\n  }\n  placePieces() {\n    for (let i = 0; i < 8; i++) {\n      for (let j = 0; j < 8; j++) {\n        const square = this.grid[i][j];\n        if (square !== ' ') {\n          const color = square === square.toLowerCase() ? 'black' : 'white';\n          const type = square.toLowerCase();\n          const imagePath = `images/${color}${type.charAt(0).toUpperCase()}${type.slice(1)}.png`;\n          const element = squareElements[i][j];\n          this.pieces.push(new Piece(type, color, i, j, imagePath, element));\n        }\n      }\n    }\n  }\n\n  getPiece(row, col) {\n    if (row < 0 || row > 7 || col < 0 || col > 7) {\n      return null;\n    }\n    return this.pieces[row][col];\n  }\n\n  movePiece(pieceElement, destinationElement) {\n    const currentSquareElement = pieceElement.parentElement;\n    // Check if the destination element is a valid square\n    if (destinationElement && destinationElement.classList.contains(\"chess-square\")) {\n      // Get the current square element\n\n      // Check if the current square element is a valid square\n      if (currentSquareElement && currentSquareElement.classList.contains(\"chess-square\")) {\n        // Check if the move is legal (e.g., using chess rules)\n        if (this.isLegalMove(pieceElement, currentSquareElement, destinationElement)) {\n          // Check if the move is valid (e.g., not putting oneself in check)\n          if (this.isValidMove(pieceElement, currentSquareElement, destinationElement)) {\n            const capturedPiece = destinationElement.firstElementChild;\n            if (capturedPiece) {\n              // Play the capture sound\n              this.playCaptureSound();\n            } else {\n              // Play the move sound\n              this.playMoveSound();\n            }\n            // Move the piece to the new square\n            destinationElement.appendChild(pieceElement);\n            currentSquareElement.innerHTML = \"\";\n            // Update the game state\n            this.updateGameState(pieceElement, destinationElement);\n          } else {\n            console.error('Error: Invalid move');\n          }\n        } else {\n          console.error('Error: Illegal move');\n        }\n      } else {\n        console.error('Error: Current square is invalid');\n      }\n    } else {\n      console.error('Error: Destination square is invalid');\n    }\n  }\n\n  createBoardElements() {\n    this.squareElements = [];\n    for (let i = 0; i < 8; i++) {\n      this.squareElements[i] = [];\n      for (let j = 0; j < 8; j++) {\n        this.squareElements[i][j] = document.getElementById(`${i}-${j}`);\n      }\n    }\n    this.createBoard();\n    this.displayBoard();\n  }\n\n  isCheckmate(color) {\n    // logic for checking if the specified color is in checkmate\n  }\n\n  isDraw() {\n    // check if there are only kings left on the board\n    if (getNumWhitePieces() == 1 && getNumBlackPieces() == 1) {\n      return true;\n    }\n    // check if there are only kings and bishops left on the board\n    if (getNumWhitePieces() == 2 && getNumBlackPieces() == 2) {\n      // check that each player has one bishop\n      if (getNumWhiteBishops() == 1 && getNumBlackBishops() == 1) {\n        return true;\n      }\n    }\n    // if none of the above conditions are met, the game is not a draw\n    return false;\n  }\n  getNumBlackBishops() {\n    let getNumBlackPieces = 0;\n\n    // Iterate through the board array\n    for (let i = 0; i < this.board.length; i++) {\n      for (let j = 0; j < this.board[i].length; j++) {\n        // Check if the current element is a black piece\n        if (this.board[i][j] === 'B') {\n          // Increment the counter\n          getNumBlackPieces++;\n        }\n      }\n      return numWhitePieces;\n    }\n  }\n\n  getNumWhiteBishops() {\n    let getNumWhiteBishops = 0;\n\n    // Iterate through the board array\n    for (let i = 0; i < this.board.length; i++) {\n      for (let j = 0; j < this.board[i].length; j++) {\n        // Check if the current element is a black piece\n        if (this.board[i][j] === 'B') {\n          // Increment the counter\n          getNumBlackPieces++;\n        }\n      }\n      return numWhitePieces;\n    }\n  }\n  getNumBlackPieces() {\n    // Initialize a counter to 0\n    let getNumBlackPieces = 0;\n\n    // Iterate through the board array\n    for (let i = 0; i < this.board.length; i++) {\n      for (let j = 0; j < this.board[i].length; j++) {\n        // Check if the current element is a black piece\n        if (this.board[i][j] === 'B') {\n          // Increment the counter\n          getNumBlackPieces++;\n        }\n      }\n    }\n    return numWhitePieces;\n  }\n  getNumWhitePieces() {\n    // Initialize a counter to 0\n    let numWhitePieces = 0;\n\n    // Iterate through the board array\n    for (let i = 0; i < this.board.length; i++) {\n      for (let j = 0; j < this.board[i].length; j++) {\n        // Check if the current element is a white piece\n        if (this.board[i][j] === 'W') {\n          // Increment the counter\n          numWhitePieces++;\n        }\n      }\n    }\n\n    // Return the number of white pieces\n    return numWhitePieces;\n  }\n  generateBoardHTML() {\n    // Create an empty string to store the HTML for the board\n    let boardHTML = '';\n\n    // Loop through the rows and columns of the board\n    for (let i = 0; i < 8; i++) {\n      for (let j = 0; j < 8; j++) {\n        // Generate HTML for the square\n        boardHTML += `<div class=\"chess-square ${(i + j) % 2 == 0 ? 'white' : 'black'}\" id=\"square-${i}-${j}\"></div>`;\n\n        // Get the piece at the current position on the board\n        const piece = this.pieces.find(piece => piece.position.row === i && piece.position.col === j);\n\n        // If there is a piece at the current position, generate HTML for it and append it to the square\n        if (piece) {\n          boardHTML += `<div class=\"chess-piece ${piece.color}-${piece.type}\" id=\"piece-${i}-${j}\"></div>`;\n        }\n      }\n    }\n\n    // Append the generated HTML to the #chessboard element\n    const boardElement = document.getElementById('chessboard');\n    boardElement.innerHTML = boardHTML;\n  }\n  createBoard() {\n    // Initialize the board array\n    this.squareElements = [];\n    for (let row = 0; row < 8; row++) {\n      this.squareElements[row] = [];\n      for (let col = 0; col < 8; col++) {\n        // Create a new square element and add it to the board array\n        const squareElement = document.createElement(\"div\");\n        squareElement.classList.add(`chess-square-${(row + col) % 2 === 0 ? 'white' : 'black'}`);\n        squareElement.dataset.row = row;\n        squareElement.dataset.col = col;\n        this.squareElements[row][col] = squareElement;\n\n        // Create a new Piece object and store it in the this.pieces array\n        const type = this.grid[row][col];\n        if (type !== ' ') {\n          const color = type === type.toUpperCase() ? 'white' : 'black';\n          const imagePath = `images/${color}${type.toUpperCase()}.png`;\n          const piece = new chessPiece(type, color, row, col, imagePath, squareElement);\n          this.pieces.push(piece);\n          squareElement.appendChild(piece.element);\n        }\n        // Add event listeners to the square element\n        squareElement.addEventListener('click', e => {\n          this.handleSquareClick(e.target);\n        });\n\n        // Add the square element to the DOM\n        document.getElementById('chessboard').appendChild(squareElement);\n      }\n    }\n  }\n\n  displayBoard() {\n    // Get a reference to the HTML element that represents the board\n    const boardElement = document.getElementById(\"chessboard\");\n    boardElement.innerHTML = '';\n    // Create a 2D array to store the square elements\n\n    // Loop through the rows and columns of the board\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        // Get the current piece at this position on the board\n        const piece = this.getPiece(row, col);\n\n        // If there is a piece at this position...\n        if (piece) {\n          // Create a new HTML element for the piece\n          const squareElement = document.createElement(\"div\");\n          squareElement.classList.add(`chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`);\n\n          // Add the piece element to the chess board element\n          boardElement.appendChild(squareElement);\n        }\n      }\n    }\n  }\n  addEventListeners() {\n    const squares = document.querySelectorAll('.chess-square');\n    squares.forEach(square => {\n      square.addEventListener('click', event => {\n        this.handleSquareClick(event);\n      });\n    });\n  }\n}\nexport default chessBoard;","import chessBoard from './classBoard.js';\n//import chessPiece from './classPiece.js';\n\nclass chessGame {\n  constructor() {\n    this.board = new Board();\n    this.whitePieces = [];\n    this.blackPieces = [];\n    this.currentTurn = 'white';\n    this.squares = document.querySelectorAll('.chess-square');\n  }\n  startNewGame() {\n    this.setupEventListeners();\n    // If the game is already over, display a message and return\n    if (this.checkGameOver()) {\n      alert(\"The game is already over. Please start a new game.\");\n      return;\n    }\n\n    // Reset the board to the starting position\n    this.board.grid = [[{ color: 'white', type: 'rook' }, { color: 'white', type: 'knight' }, { color: 'white', type: 'bishop' }, { color: 'white', type: 'queen' }, { color: 'white', type: 'king' }, { color: 'white', type: 'bishop' }, { color: 'white', type: 'knight' }, { color: 'white', type: 'rook' }], [{ color: 'white', type: 'pawn' }, { color: 'white', type: 'pawn' }, { color: 'white', type: 'pawn' }, { color: 'white', type: 'pawn' }, { color: 'white', type: 'pawn' }, { color: 'white', type: 'pawn' }, { color: 'white', type: 'pawn' }, { color: 'white', type: 'pawn' }], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [{ color: 'black', type: 'pawn' }, { color: 'black', type: 'pawn' }, { color: 'black', type: 'pawn' }, { color: 'black', type: 'pawn' }, { color: 'black', type: 'pawn' }, { color: 'black', type: 'pawn' }, { color: 'black', type: 'pawn' }, { color: 'black', type: 'pawn' }], [{ color: 'black', type: 'rook' }, { color: 'black', type: 'knight' }, { color: 'black', type: 'bishop' }, { color: 'black', type: 'queen' }, { color: 'black', type: 'king' }, { color: 'black', type: 'bishop' }, { color: 'black', type: 'knight' }, { color: 'black', type: 'rook' }]];\n    this.whiteTurn = true;\n    this.selectedPiece = null;\n    this.checkGameOver = () => {};\n\n    squares.forEach(square => square.innerHTML = \"\");\n\n    this.board.placePieces();\n  }\n  handleMove(fromRow, fromCol, toRow, toCol) {\n    // check if the move is legal and update the board and pieces accordingly\n  }\n\n  isCheckmate(color) {\n    // check if the player with the specified color is in checkmate\n  }\n\n  setupEventListeners() {\n    // Initialize the board array\n    const squares = document.querySelectorAll('.chess-square');\n    const pieces = document.querySelectorAll('.chess-piece');\n\n    // Add event listeners to each square and piece\n    squares.forEach(square => {\n      square.addEventListener('click', event => {\n        // Handle square click event\n        highlightSquare(event.target);\n      });\n    });\n    pieces.forEach(piece => {\n      piece.addEventListener('click', event => {\n        // Handle piece click event\n      });\n    });\n  }\n  highlightSquare(squareElement) {\n    // Check if the clicked square is occupied by a piece\n    if (squareElement.children.length > 0) {\n      // Get the piece element\n      const pieceElement = squareElement.children[0];\n\n      // Check if the piece is the correct color (based on the current player turn)\n      if (this.isWhiteTurn && pieceElement.classList.contains('white') || !this.isWhiteTurn && pieceElement.classList.contains('black')) {\n        // Deselect the previously selected piece (if there was one)\n        if (this.selectedPiece) {\n          this.selectedPiece.classList.remove('highlight');\n        }\n\n        // Add the 'highlight' class to the square element\n        squareElement.classList.add('highlight');\n\n        // Update the selected piece\n        this.selectedPiece = squareElement;\n        console.log(piece);\n      }\n    }\n  }\n}\nexport default chessGame;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(140);\n__webpack_require__(359);\nvar __webpack_exports__ = __webpack_require__(756);\n"],"names":["chessGame","_classCallCheck","this","board","Board","whitePieces","blackPieces","currentTurn","squares","document","querySelectorAll","key","value","setupEventListeners","checkGameOver","alert","grid","color","type","whiteTurn","selectedPiece","forEach","square","innerHTML","placePieces","fromRow","fromCol","toRow","toCol","pieces","addEventListener","event","highlightSquare","target","piece","squareElement","children","length","pieceElement","isWhiteTurn","classList","contains","remove","add","console","log","chessBoard","squareElements","Array","fill","map","i","j","getElementById","concat","createElements","chessPieces","createBoard","displayBoard","updateGameState","toLowerCase","charAt","toUpperCase","slice","addEventListeners","handleClick","bind","currentlySelectedPiece","parseInt","dataset","row","col","parentElement","movePiece","imagePath","element","push","Piece","destinationElement","currentSquareElement","isLegalMove","isValidMove","firstElementChild","playCaptureSound","playMoveSound","appendChild","error","getNumWhitePieces","getNumBlackPieces","getNumWhiteBishops","getNumBlackBishops","numWhitePieces","_this","boardHTML","_loop","_loop2","find","position","_this2","createElement","chessPiece","e","handleSquareClick","boardElement","getPiece","_this3","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag"],"sourceRoot":""}